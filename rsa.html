<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Assinatura Digital RSA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsbn/1.1.0/jsbn.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        position: relative;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        max-width: 900px;
        width: 100%;
        position: relative;
        overflow: hidden;
      }

      .container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #667eea, #764ba2, #667eea);
      }

      @keyframes shimmer {
        0%,
        100% {
          transform: translateX(-100%);
        }
        50% {
          transform: translateX(100%);
        }
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 2.2em;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .menu {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        align-items: center;
      }

      .menu-button {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 20px;
        border-radius: 15px;
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .menu-button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .menu-button:hover::before {
        left: 100%;
      }

      .menu-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }

      .section {
        display: none;
        background: rgba(255, 255, 255, 0.8);
        padding: 30px;
        border-radius: 15px;
        margin-top: 20px;
        border: 1px solid rgba(102, 126, 234, 0.2);
      }

      .section.active {
        display: block;
        animation: fadeInUp 0.5s ease;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        color: #333;
        font-weight: 600;
      }

      input[type="text"],
      input[type="file"],
      textarea {
        width: 100%;
        padding: 12px;
        border: 2px solid #e1e5e9;
        border-radius: 10px;
        font-size: 16px;
        transition: border-color 0.3s ease;
      }

      input[type="text"]:focus,
      input[type="file"]:focus,
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      textarea {
        height: 150px;
        resize: vertical;
        font-family: "Courier New", monospace;
      }

      .action-button {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 10px;
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
      }

      .back-button {
        background: linear-gradient(135deg, #6c757d, #495057);
      }

      .back-button:hover {
        box-shadow: 0 8px 20px rgba(108, 117, 125, 0.3);
      }

      .result-area {
        margin-top: 20px;
        padding: 20px;
        background: rgba(248, 249, 250, 0.8);
        border-radius: 10px;
        border-left: 4px solid #667eea;
        display: none;
      }

      .result-area.show {
        display: block;
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .success {
        color: #28a745;
        background: rgba(40, 167, 69, 0.1);
        border-color: #28a745;
      }

      .error {
        color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
        border-color: #dc3545;
      }

      .loading {
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .key-display {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        word-break: break-all;
        font-family: "Courier New", monospace;
        font-size: 0.9em;
        border: 1px solid #dee2e6;
      }

      .file-info {
        background: rgba(102, 126, 234, 0.1);
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid rgba(102, 126, 234, 0.2);
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
          margin: 10px;
        }

        h1 {
          font-size: 1.8em;
        }

        .menu {
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 100%;
          justify-content: center;
        }
      }

      .authors {
        text-align: center;
        margin-top: 20px;
        width: 100%;
        justify-content: center;
        margin-top: 20px;
        font-size: 1.1em;
        align-items: center;
        color: #666;
      }
      .home-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #333;
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .home-button:hover {
        color: #000;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <button
        class="home-button"
        onclick="window.location.href='index.html'"
        aria-label="Voltar ao in√≠cio"
      >
        <!-- Left arrow svg -->
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="4"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="M15 18l-6-6 6-6" />
        </svg>
      </button>

      <h1>üîê Assinatura Digital RSA</h1>

      <div id="main-menu" class="menu">
        <button class="menu-button" onclick="showSection('generate-keys')">
          Gerar Chaves RSA
        </button>
        <button class="menu-button" onclick="showSection('sign-file')">
          Assinar Arquivo
        </button>
        <button class="menu-button" onclick="showSection('verify-signature')">
          Verificar Assinatura
        </button>
        <button class="menu-button" onclick="showSection('extract-message')">
          Extrair Mensagem
        </button>
      </div>

      <div class="authors">
        <p>Feito por Yan Tavares e Eduardo Marques</p>
      </div>

      <!-- Se√ß√£o Gerar Chaves -->
      <div id="generate-keys" class="section">
        <h2>üóùÔ∏è Gerar Par de Chaves RSA</h2>
        <p>
          Gerando chaves RSA de 2048 bits com teste de primalidade Miller-Rabin
        </p>
        <br />
        <button class="action-button" onclick="generateKeys()">
          Gerar Chaves
        </button>
        <button class="action-button back-button" onclick="showMainMenu()">
          Voltar
        </button>

        <div id="key-generation-result" class="result-area">
          <div class="progress-bar">
            <div id="key-progress" class="progress-fill"></div>
          </div>
          <div id="key-status"></div>
          <div id="public-key-display"></div>
          <div id="private-key-display"></div>
        </div>
      </div>

      <!-- Se√ß√£o Assinar Arquivo -->
      <div id="sign-file" class="section">
        <h2>‚úçÔ∏è Assinar Arquivo</h2>
        <div class="form-group">
          <label for="file-to-sign">Selecione o arquivo para assinar:</label>
          <input type="file" id="file-to-sign" accept="*/*" />
        </div>
        <div class="form-group">
          <label for="private-key-input"
            >Chave Privada (formato: n,d em hexadecimal):</label
          >
          <textarea
            id="private-key-input"
            placeholder="Digite ou cole a chave privada aqui..."
          ></textarea>
        </div>
        <button class="action-button" onclick="signFile()">
          Assinar Arquivo
        </button>
        <button class="action-button back-button" onclick="showMainMenu()">
          Voltar
        </button>

        <div id="sign-result" class="result-area"></div>
      </div>

      <!-- Se√ß√£o Verificar Assinatura -->
      <div id="verify-signature" class="section">
        <h2>‚úÖ Verificar Assinatura</h2>
        <div class="form-group">
          <label for="signed-file"
            >Selecione o arquivo assinado (.signed):</label
          >
          <input type="file" id="signed-file" accept=".signed,*/*" />
        </div>
        <div class="form-group">
          <label for="public-key-input"
            >Chave P√∫blica (formato: n,e em hexadecimal):</label
          >
          <textarea
            id="public-key-input"
            placeholder="Digite ou cole a chave p√∫blica aqui..."
          ></textarea>
        </div>
        <button class="action-button" onclick="verifySignature()">
          Verificar Assinatura
        </button>
        <button class="action-button back-button" onclick="showMainMenu()">
          Voltar
        </button>

        <div id="verify-result" class="result-area"></div>
      </div>

      <!-- Se√ß√£o Extrair Mensagem -->
      <div id="extract-message" class="section">
        <h2>üìÑ Extrair Mensagem Original</h2>
        <div class="form-group">
          <label for="extract-file">Selecione o arquivo assinado:</label>
          <input type="file" id="extract-file" accept=".signed,*/*" />
        </div>
        <button class="action-button" onclick="extractMessage()">
          Extrair Mensagem
        </button>
        <button class="action-button back-button" onclick="showMainMenu()">
          Voltar
        </button>

        <div id="extract-result" class="result-area"></div>
      </div>
    </div>

    <script>
      // Estado global da aplica√ß√£o
      let currentKeys = {
        public: null,
        private: null,
      };

      // Implementa√ß√£o SHA3-256 simplificada usando CryptoJS
      function sha3Hash(data) {
        return CryptoJS.SHA3(data, { outputLength: 256 }).toString(
          CryptoJS.enc.Hex
        );
      }

      // Fun√ß√µes de utilidade para convers√µes
      function hexToBytes(hex) {
        const bytes = [];
        for (let i = 0; i < hex.length; i += 2) {
          bytes.push(parseInt(hex.substr(i, 2), 16));
        }
        return new Uint8Array(bytes);
      }

      function bytesToHex(bytes) {
        return Array.from(bytes)
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }

      function stringToBytes(str) {
        return new TextEncoder().encode(str);
      }

      function bytesToString(bytes) {
        return new TextDecoder().decode(bytes);
      }

      // Implementa√ß√£o Base64
      function base64Encode(bytes) {
        return btoa(String.fromCharCode(...bytes));
      }

      function base64Decode(str) {
        return new Uint8Array(
          atob(str)
            .split("")
            .map((c) => c.charCodeAt(0))
        );
      }

      // Fun√ß√£o de gera√ß√£o de n√∫meros primos (simplificada para demonstra√ß√£o)
      function isProbablyPrime(n, k = 5) {
        if (n < 2) return false;
        if (n === 2 || n === 3) return true;
        if (n % 2 === 0) return false;

        // Miller-Rabin simplificado
        let d = n - 1;
        let r = 0;
        while (d % 2 === 0) {
          d /= 2;
          r++;
        }

        for (let i = 0; i < k; i++) {
          const a = 2 + Math.floor(Math.random() * (n - 4));
          let x = Math.pow(a, d) % n;
          if (x === 1 || x === n - 1) continue;

          let composite = true;
          for (let j = 0; j < r - 1; j++) {
            x = (x * x) % n;
            if (x === n - 1) {
              composite = false;
              break;
            }
          }
          if (composite) return false;
        }
        return true;
      }

      // Gera√ß√£o de chaves RSA simplificada
      function generateRSAKeys() {
        // Para demonstra√ß√£o, usamos n√∫meros menores (em produ√ß√£o seria 2048 bits)
        const p = generatePrime(512);
        const q = generatePrime(512);
        const n = p * q;
        const phi = (p - 1) * (q - 1);
        const e = 65537;
        const d = modInverse(e, phi);

        return {
          public: { n: n.toString(16), e: e.toString(16) },
          private: { n: n.toString(16), d: d.toString(16) },
        };
      }

      function generatePrime(bits) {
        let candidate;
        do {
          candidate =
            Math.floor(Math.random() * Math.pow(2, bits / 4)) +
            Math.pow(2, bits / 4 - 1);
          if (candidate % 2 === 0) candidate++;
        } while (!isProbablyPrime(candidate));
        return candidate;
      }

      function gcd(a, b) {
        while (b !== 0) {
          let temp = b;
          b = a % b;
          a = temp;
        }
        return a;
      }

      function modInverse(a, m) {
        if (gcd(a, m) !== 1) return null;
        let m0 = m,
          x0 = 0,
          x1 = 1;
        while (a > 1) {
          let q = Math.floor(a / m);
          let t = m;
          m = a % m;
          a = t;
          t = x0;
          x0 = x1 - q * x0;
          x1 = t;
        }
        return x1 < 0 ? x1 + m0 : x1;
      }

      // Padding OAEP simplificado
      function oaepPad(message, keySize) {
        const hLen = 32; // SHA3-256 hash length
        const maxMsgLen = keySize - 2 * hLen - 2;

        if (message.length > maxMsgLen) {
          throw new Error("Mensagem muito longa para OAEP");
        }

        // Construir DB (simplificado)
        const lHash = new Uint8Array(hLen); // Hash da label vazia
        const ps = new Uint8Array(maxMsgLen - message.length);
        const db = new Uint8Array(hLen + ps.length + 1 + message.length);

        db.set(lHash, 0);
        db.set(ps, hLen);
        db[hLen + ps.length] = 0x01;
        db.set(message, hLen + ps.length + 1);

        // Seed aleat√≥ria
        const seed = new Uint8Array(hLen);
        crypto.getRandomValues(seed);

        // MGF1 simplificado
        const dbMask = mgf1(seed, db.length);
        const maskedDB = new Uint8Array(db.length);
        for (let i = 0; i < db.length; i++) {
          maskedDB[i] = db[i] ^ dbMask[i];
        }

        const seedMask = mgf1(maskedDB, hLen);
        const maskedSeed = new Uint8Array(hLen);
        for (let i = 0; i < hLen; i++) {
          maskedSeed[i] = seed[i] ^ seedMask[i];
        }

        // Construir EM
        const em = new Uint8Array(keySize);
        em[0] = 0x00;
        em.set(maskedSeed, 1);
        em.set(maskedDB, 1 + hLen);

        return em;
      }

      function mgf1(seed, length) {
        const mask = new Uint8Array(length);
        let offset = 0;
        for (let counter = 0; offset < length; counter++) {
          const c = new Uint8Array(4);
          c[0] = (counter >>> 24) & 0xff;
          c[1] = (counter >>> 16) & 0xff;
          c[2] = (counter >>> 8) & 0xff;
          c[3] = counter & 0xff;

          const combined = new Uint8Array(seed.length + 4);
          combined.set(seed);
          combined.set(c, seed.length);

          const hash = hexToBytes(
            sha3Hash(CryptoJS.lib.WordArray.create(combined))
          );
          const copyLen = Math.min(hash.length, length - offset);
          mask.set(hash.slice(0, copyLen), offset);
          offset += copyLen;
        }
        return mask;
      }

      // Interface Functions
      function showSection(sectionId) {
        document
          .querySelectorAll(".section")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById("main-menu").style.display = "none";
        document.getElementById(sectionId).classList.add("active");
      }

      function showMainMenu() {
        document
          .querySelectorAll(".section")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById("main-menu").style.display = "flex";
      }

      function showResult(elementId, content, isSuccess = true) {
        const element = document.getElementById(elementId);
        element.innerHTML = content;
        element.className = `result-area show ${
          isSuccess ? "success" : "error"
        }`;
      }

      async function generateKeys() {
        const resultDiv = document.getElementById("key-generation-result");
        const progressBar = document.getElementById("key-progress");
        const statusDiv = document.getElementById("key-status");

        resultDiv.classList.add("show");
        statusDiv.innerHTML =
          '<div class="loading"><div class="spinner"></div>Gerando chaves RSA...</div>';

        // Simular progresso
        for (let i = 0; i <= 100; i += 10) {
          progressBar.style.width = i + "%";
          await new Promise((resolve) => setTimeout(resolve, 100));
        }

        try {
          const keys = generateRSAKeys();
          currentKeys = keys;

          statusDiv.innerHTML = "‚úÖ Chaves geradas com sucesso!";

          document.getElementById("public-key-display").innerHTML = `
                    <h4>üîë Chave P√∫blica:</h4>
                    <div class="key-display">
                        <strong>n:</strong> ${keys.public.n}<br>
                        <strong>e:</strong> ${keys.public.e}
                    </div>
                    <button class="action-button" onclick="downloadKey('public', '${keys.public.n},${keys.public.e}')">üì• Baixar Chave P√∫blica</button>
                `;

          document.getElementById("private-key-display").innerHTML = `
                    <h4>üîí Chave Privada:</h4>
                    <div class="key-display">
                        <strong>n:</strong> ${keys.private.n}<br>
                        <strong>d:</strong> ${keys.private.d}
                    </div>
                    <button class="action-button" onclick="downloadKey('private', '${keys.private.n},${keys.private.d}')">üì• Baixar Chave Privada</button>
                `;
        } catch (error) {
          statusDiv.innerHTML = "‚ùå Erro ao gerar chaves: " + error.message;
          resultDiv.className = "result-area show error";
        }
      }

      function downloadKey(type, keyData) {
        const blob = new Blob([keyData], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${type}_key.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // --- Fun√ß√£o de assinatura corrigida ---
      async function signFile() {
        const fileInput = document.getElementById("file-to-sign");
        const privateKeyInput = document.getElementById("private-key-input");

        if (!fileInput.files[0]) {
          showResult(
            "sign-result",
            "‚ùå Por favor, selecione um arquivo para assinar.",
            false
          );
          return;
        }
        if (!privateKeyInput.value.trim()) {
          showResult(
            "sign-result",
            "‚ùå Por favor, insira a chave privada.",
            false
          );
          return;
        }

        try {
          const file = fileInput.files[0];
          const fileContent = new Uint8Array(await file.arrayBuffer());
          const [nHex, dHex] = privateKeyInput.value.trim().split(",");

          // 1) Hash do arquivo
          const fileHash = sha3Hash(CryptoJS.lib.WordArray.create(fileContent));
          const hashBytes = hexToBytes(fileHash);

          // 2) keySize via BigInt
          const nBig = BigInt("0x" + nHex);
          const bitLen = nBig.toString(2).length;
          const keySize = Math.ceil(bitLen / 8);

          // 3) OAEP pad
          const em = oaepPad(hashBytes, keySize);
          const emHex = bytesToHex(em);
          const mBig = BigInt("0x" + emHex);
          const dBig = BigInt("0x" + dHex);

          // 4) RSA-sign: m^d mod n
          const sigBig = modPow(mBig, dBig, nBig);
          // garante comprimento constante em hex (keySize * 2 d√≠gitos)
          const sigHex = sigBig.toString(16).padStart(keySize * 2, "0");
          const sigBytes = hexToBytes(sigHex);
          const sigB64 = base64Encode(sigBytes);

          // 5) Monta o arquivo assinado
          const contentB64 = base64Encode(fileContent);
          const signedText = [
            "-----BEGIN SIGNED MESSAGE-----",
            contentB64,
            "-----BEGIN SIGNATURE-----",
            sigB64,
            "-----END SIGNATURE-----",
          ].join("\n");

          // download‚Ä¶.
          const blob = new Blob([signedText], { type: "text/plain" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${file.name}.signed`;
          a.click();
          URL.revokeObjectURL(url);

          showResult(
            "sign-result",
            `
      ‚úÖ Arquivo assinado com sucesso!
      <div class="file-info">
        <strong>Arquivo:</strong> ${file.name}<br>
        <strong>Hash SHA3-256:</strong> ${fileHash}
      </div>
      <p>O arquivo .signed foi baixado automaticamente.</p>
    `
          );
        } catch (err) {
          showResult(
            "sign-result",
            "‚ùå Erro ao assinar arquivo: " + err.message,
            false
          );
        }
      }

      // --- Fun√ß√£o de verifica√ß√£o corrigida ---
      async function verifySignature() {
        const fileInput = document.getElementById("signed-file");
        const publicKeyInput = document.getElementById("public-key-input");

        if (!fileInput.files[0]) {
          showResult(
            "verify-result",
            "‚ùå Por favor, selecione um arquivo assinado.",
            false
          );
          return;
        }
        if (!publicKeyInput.value.trim()) {
          showResult(
            "verify-result",
            "‚ùå Por favor, insira a chave p√∫blica.",
            false
          );
          return;
        }

        try {
          const file = fileInput.files[0];
          const text = await file.text();
          const [nHex, eHex] = publicKeyInput.value.trim().split(",");

          // 1) Extrai conte√∫do e assinatura
          const lines = text.split("\n");
          let inMsg = false,
            inSig = false,
            contentB64 = "",
            sigB64 = "";
          for (let l of lines) {
            if (l.includes("BEGIN SIGNED MESSAGE")) {
              inMsg = true;
              continue;
            }
            if (l.includes("BEGIN SIGNATURE")) {
              inMsg = false;
              inSig = true;
              continue;
            }
            if (l.includes("END SIGNATURE")) break;
            if (inMsg) contentB64 += l.trim();
            if (inSig) sigB64 += l.trim();
          }
          if (!contentB64 || !sigB64)
            throw new Error("Formato de arquivo assinado inv√°lido");

          // 2) Decodifica e calcula hash
          const originalBytes = base64Decode(contentB64);
          const calcHash = sha3Hash(
            CryptoJS.lib.WordArray.create(originalBytes)
          );

          // 3) Prepara BigInts e keySize
          const nBig = BigInt("0x" + nHex);
          const eBig = BigInt("0x" + eHex);
          const bitLen = nBig.toString(2).length;
          const keySize = Math.ceil(bitLen / 8);

          // 4) Decodifica assinatura Base64‚Üíbytes‚ÜíBigInt
          const sigBytes = base64Decode(sigB64);
          const sigHex = bytesToHex(sigBytes);
          const sigBig = BigInt("0x" + sigHex);

          // 5) RSA-verify: sig^e mod n = EM
          const emBig = modPow(sigBig, eBig, nBig);
          const emHex = emBig.toString(16).padStart(keySize * 2, "0");
          const em = hexToBytes(emHex);

          // 6) OAEP-unpad ‚Üí recupera hash
          const recoveredHashBytes = oaepUnpad(em);
          const recHashHex = bytesToHex(recoveredHashBytes);

          // 7) Compara
          if (recHashHex === calcHash) {
            showResult(
              "verify-result",
              `
        üéâ ASSINATURA V√ÅLIDA!
        <div class="file-info">
          <strong>Arquivo:</strong> ${file.name}<br>
          <strong>Hash calculado:</strong> ${calcHash}<br>
          <strong>Hash recuperado:</strong> ${recHashHex}
        </div>
      `
            );
          } else {
            showResult("verify-result", "‚ùå ASSINATURA INV√ÅLIDA!", false);
          }
        } catch (err) {
          showResult(
            "verify-result",
            "‚ùå Erro ao verificar assinatura: " + err.message,
            false
          );
        }
      }

      // --- Implementa√ß√£o de unpad OAEP (inverte o oaepPad) ---
      function oaepUnpad(em) {
        const hLen = 32;
        // em = 0x00 || maskedSeed[hLen] || maskedDB[keySize-1-hLen]
        const maskedSeed = em.slice(1, 1 + hLen);
        const maskedDB = em.slice(1 + hLen);

        // seed = maskedSeed ^ MGF1(maskedDB, hLen)
        const seedMask = mgf1(maskedDB, hLen);
        const seed = maskedSeed.map((b, i) => b ^ seedMask[i]);

        // db = maskedDB ^ MGF1(seed, dbLen)
        const dbMask = mgf1(seed, maskedDB.length);
        const db = maskedDB.map((b, i) => b ^ dbMask[i]);

        // verifica lHash (todos zeros) e busca 0x01
        let idx = hLen;
        while (db[idx] === 0x00) idx++;
        if (db[idx] !== 0x01) throw new Error("Erro no unpad OAEP");

        // retorna s√≥ os bytes ap√≥s o 0x01
        return db.slice(idx + 1);
      }
      // --- fun√ß√£o para remover OAEP (simplificada) ---
      function oaepUnpad(em) {
        const hLen = 32;
        const maskedSeed = em.slice(1, 1 + hLen);
        const maskedDB = em.slice(1 + hLen);

        const seedMask = mgf1(maskedDB, hLen);
        const seed = maskedSeed.map((b, i) => b ^ seedMask[i]);

        const dbMask = mgf1(seed, maskedDB.length);
        const db = maskedDB.map((b, i) => b ^ dbMask[i]);

        // pular lHash (hLen) e todos os 0x00 at√© encontrar 0x01
        let idx = hLen;
        while (db[idx] === 0x00) idx++;
        if (db[idx] !== 0x01) throw new Error("Erro no unpad OAEP");

        // a mensagem ‚Äúrecuperada‚Äù √© tudo depois do 0x01
        return db.slice(idx + 1);
      }
      async function extractMessage() {
        const fileInput = document.getElementById("extract-file");
        if (!fileInput.files[0]) {
          showResult(
            "extract-result",
            "‚ùå Por favor, selecione um arquivo assinado.",
            false
          );
          return;
        }

        try {
          const file = fileInput.files[0];
          const text = await file.text();

          // Extrai s√≥ o bloco de mensagem em Base64
          const lines = text.split("\n");
          let inMsg = false,
            contentB64 = "";
          for (let l of lines) {
            if (l.includes("BEGIN SIGNED MESSAGE")) {
              inMsg = true;
              continue;
            }
            if (l.includes("BEGIN SIGNATURE")) {
              break;
            }
            if (inMsg) contentB64 += l.trim();
          }
          if (!contentB64)
            throw new Error("Conte√∫do n√£o encontrado no arquivo assinado");

          // Decodifica Base64 ‚Üí bytes ‚Üí string
          const bytes = base64Decode(contentB64);
          let message;
          try {
            message = bytesToString(bytes);
          } catch {
            // Se n√£o for texto UTF-8, cai aqui
            message = "[conte√∫do bin√°rio n√£o √© texto leg√≠vel]";
          }

          // Exibe na tela
          showResult(
            "extract-result",
            `
      ‚úÖ Mensagem extra√≠da com sucesso!
      <div class="file-info">
        <strong>Arquivo fonte:</strong> ${file.name}<br>
        <strong>Tamanho extra√≠do:</strong> ${bytes.length} bytes
      </div>
      <h4>üìú Conte√∫do:</h4>
      <pre style="white-space: pre-wrap; background: #f0f0f0; padding: 10px; border-radius: 5px;">${message}</pre>
    `
          );
        } catch (err) {
          showResult(
            "extract-result",
            "‚ùå Erro ao extrair mensagem: " + err.message,
            false
          );
        }
      }
      // Fun√ß√£o para converter BigInt para hex (compatibilidade)
      function bigIntToHex(bigIntValue) {
        return bigIntValue.toString(16);
      }

      // Fun√ß√£o para opera√ß√µes modulares grandes
      function modPow(base, exponent, modulus) {
        if (typeof base === "string") base = BigInt("0x" + base);
        if (typeof exponent === "string") exponent = BigInt("0x" + exponent);
        if (typeof modulus === "string") modulus = BigInt("0x" + modulus);

        let result = 1n;
        base = base % modulus;

        while (exponent > 0n) {
          if (exponent % 2n === 1n) {
            result = (result * base) % modulus;
          }
          exponent = exponent >> 1n;
          base = (base * base) % modulus;
        }

        return result;
      }

      // Melhorada implementa√ß√£o RSA com BigInt
      function generateRSAKeysImproved() {
        // Gerar primos de 1024 bits cada (para 2048 bits total)
        const p = generateLargePrime(1024);
        const q = generateLargePrime(1024);
        const n = p * q;
        const phi = (p - 1n) * (q - 1n);
        const e = 65537n;

        // Calcular d usando algoritmo estendido de Euclides
        const d = modInverseBig(e, phi);

        if (!d) {
          throw new Error("N√£o foi poss√≠vel calcular a chave privada");
        }

        return {
          public: {
            n: n.toString(16),
            e: e.toString(16),
          },
          private: {
            n: n.toString(16),
            d: d.toString(16),
          },
        };
      }

      function generateLargePrime(bits) {
        let candidate;
        do {
          // Gerar n√∫mero aleat√≥rio de 'bits' bits
          candidate = generateRandomBigInt(bits);
          // Garantir que √© √≠mpar
          if (candidate % 2n === 0n) candidate += 1n;
        } while (!isProbablyPrimeBig(candidate, 10));

        return candidate;
      }

      function generateRandomBigInt(bits) {
        const bytes = Math.ceil(bits / 8);
        const randomBytes = new Uint8Array(bytes);
        crypto.getRandomValues(randomBytes);

        // Garantir que o primeiro bit est√° definido (n√∫mero de tamanho correto)
        randomBytes[0] |= 0x80;

        let result = 0n;
        for (let i = 0; i < randomBytes.length; i++) {
          result = (result << 8n) + BigInt(randomBytes[i]);
        }

        return result;
      }

      function isProbablyPrimeBig(n, k = 10) {
        if (n < 2n) return false;
        if (n === 2n || n === 3n) return true;
        if (n % 2n === 0n) return false;

        // Miller-Rabin test
        let d = n - 1n;
        let r = 0;
        while (d % 2n === 0n) {
          d /= 2n;
          r++;
        }

        for (let i = 0; i < k; i++) {
          const a = 2n + BigInt(Math.floor(Math.random() * Number(n - 4n)));
          let x = modPow(a, d, n);

          if (x === 1n || x === n - 1n) continue;

          let composite = true;
          for (let j = 0; j < r - 1; j++) {
            x = modPow(x, 2n, n);
            if (x === n - 1n) {
              composite = false;
              break;
            }
          }
          if (composite) return false;
        }
        return true;
      }

      function gcdBig(a, b) {
        while (b !== 0n) {
          let temp = b;
          b = a % b;
          a = temp;
        }
        return a;
      }

      function modInverseBig(a, m) {
        if (gcdBig(a, m) !== 1n) return null;

        let m0 = m;
        let x0 = 0n,
          x1 = 1n;

        while (a > 1n) {
          let q = a / m;
          let t = m;
          m = a % m;
          a = t;
          t = x0;
          x0 = x1 - q * x0;
          x1 = t;
        }

        return x1 < 0n ? x1 + m0 : x1;
      }

      // Atualizar fun√ß√£o de gera√ß√£o de chaves para usar a implementa√ß√£o melhorada
      async function generateKeys() {
        const resultDiv = document.getElementById("key-generation-result");
        const progressBar = document.getElementById("key-progress");
        const statusDiv = document.getElementById("key-status");

        resultDiv.classList.add("show");
        statusDiv.innerHTML =
          '<div class="loading"><div class="spinner"></div>Gerando primos seguros...</div>';

        try {
          // Simular progresso durante a gera√ß√£o
          for (let i = 0; i <= 50; i += 10) {
            progressBar.style.width = i + "%";
            await new Promise((resolve) => setTimeout(resolve, 200));
          }

          statusDiv.innerHTML =
            '<div class="loading"><div class="spinner"></div>Calculando chaves RSA...</div>';

          // Dar tempo para a UI atualizar antes do c√°lculo pesado
          await new Promise((resolve) => setTimeout(resolve, 100));

          const keys = generateRSAKeysImproved();
          currentKeys = keys;

          // Finalizar progresso
          for (let i = 50; i <= 100; i += 10) {
            progressBar.style.width = i + "%";
            await new Promise((resolve) => setTimeout(resolve, 50));
          }

          statusDiv.innerHTML = "üéâ Chaves RSA 2048-bit geradas com sucesso!";

          document.getElementById("public-key-display").innerHTML = `
                    <h4>üîë Chave P√∫blica (n, e):</h4>
                    <div class="key-display">
                        <strong>n:</strong> ${keys.public.n}<br>
                        <strong>e:</strong> ${keys.public.e}
                    </div>
                    <button class="action-button" onclick="downloadKey('public', '${keys.public.n},${keys.public.e}')">üì• Baixar Chave P√∫blica</button>
                `;

          document.getElementById("private-key-display").innerHTML = `
                    <h4>üîí Chave Privada (n, d):</h4>
                    <div class="key-display">
                        <strong>n:</strong> ${keys.private.n}<br>
                        <strong>d:</strong> ${keys.private.d}
                    </div>
                    <button class="action-button" onclick="downloadKey('private', '${keys.private.n},${keys.private.d}')">üì• Baixar Chave Privada</button>
                `;
        } catch (error) {
          statusDiv.innerHTML = "‚ùå Erro ao gerar chaves: " + error.message;
          resultDiv.className = "result-area show error";
        }
      }

      // Fun√ß√£o para debug/teste
      function testRSAOperations() {
        console.log("Testando opera√ß√µes RSA...");
        try {
          const keys = generateRSAKeysImproved();
          console.log("Chaves geradas:", keys);

          // Teste de assinatura simples
          const message = "Hello RSA!";
          const messageBytes = stringToBytes(message);
          const hash = sha3Hash(CryptoJS.lib.WordArray.create(messageBytes));
          console.log("Hash da mensagem:", hash);

          console.log("Teste RSA conclu√≠do com sucesso!");
        } catch (error) {
          console.error("Erro no teste RSA:", error);
        }
      }

      // Inicializa√ß√£o
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Sistema de Assinatura Digital RSA carregado");

        // Verificar suporte para BigInt
        if (typeof BigInt === "undefined") {
          alert(
            "Este navegador n√£o suporta BigInt. Algumas funcionalidades podem n√£o funcionar corretamente."
          );
        }

        // Verificar suporte para Web Crypto API
        if (!window.crypto || !window.crypto.getRandomValues) {
          alert(
            "Este navegador n√£o suporta a Web Crypto API. A gera√ß√£o de n√∫meros aleat√≥rios pode n√£o ser segura."
          );
        }
      });

      // Adicionar event listeners para melhor UX
      document
        .getElementById("file-to-sign")
        .addEventListener("change", function (e) {
          if (e.target.files[0]) {
            const file = e.target.files[0];
            console.log(
              `Arquivo selecionado: ${file.name} (${file.size} bytes)`
            );
          }
        });

      document
        .getElementById("signed-file")
        .addEventListener("change", function (e) {
          if (e.target.files[0]) {
            const file = e.target.files[0];
            console.log(
              `Arquivo assinado selecionado: ${file.name} (${file.size} bytes)`
            );
          }
        });

      document
        .getElementById("extract-file")
        .addEventListener("change", function (e) {
          if (e.target.files[0]) {
            const file = e.target.files[0];
            console.log(
              `Arquivo para extra√ß√£o selecionado: ${file.name} (${file.size} bytes)`
            );
          }
        });
    </script>
  </body>
</html>
