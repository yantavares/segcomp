<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cifra de Vigen√®re</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #2c3e50, #4a6741);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.1em;
        opacity: 0.9;
      }

      .tabs {
        display: flex;
        background: #f8f9fa;
        border-bottom: 2px solid #e9ecef;
      }

      .tab {
        flex: 1;
        padding: 20px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.1em;
        font-weight: 600;
        transition: all 0.3s ease;
        color: #6c757d;
      }

      .tab:hover {
        background: #e9ecef;
        color: #495057;
      }

      .tab.active {
        background: white;
        color: #2c3e50;
        border-bottom: 3px solid #667eea;
      }

      .tab-content {
        display: none;
        padding: 40px;
      }

      .tab-content.active {
        display: block;
      }

      .form-group {
        margin-bottom: 25px;
      }

      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #2c3e50;
        font-size: 1.1em;
      }

      .form-group input,
      .form-group textarea,
      .form-group select {
        width: 100%;
        padding: 15px;
        border: 2px solid #e9ecef;
        border-radius: 10px;
        font-size: 1em;
        transition: all 0.3s ease;
        background: white;
      }

      .form-group input:focus,
      .form-group textarea:focus,
      .form-group select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .form-group textarea {
        min-height: 150px;
        resize: vertical;
        font-family: "Courier New", monospace;
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
      }

      .file-input {
        width: 100%;
        padding: 15px;
        border: 2px dashed #667eea;
        border-radius: 10px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #f8f9ff;
      }

      .file-input:hover {
        background: #f0f0ff;
        border-color: #5a6fd8;
      }

      .file-input input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .btn {
        padding: 15px 30px;
        border: none;
        border-radius: 10px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn-secondary:hover {
        background: #5a6268;
        transform: translateY(-2px);
      }

      .btn-success {
        background: #28a745;
        color: white;
      }

      .btn-success:hover {
        background: #218838;
        transform: translateY(-2px);
      }

      .result-area {
        margin-top: 30px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 10px;
        border-left: 5px solid #667eea;
      }

      .result-area h3 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .result-text {
        background: white;
        padding: 20px;
        border-radius: 8px;
        font-family: "Courier New", monospace;
        font-size: 0.95em;
        line-height: 1.5;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #e9ecef;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin: 20px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
      }

      .analysis-results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .analysis-card {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-left: 4px solid #667eea;
      }

      .analysis-card h4 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-size: 1.1em;
      }

      .analysis-card .value {
        font-size: 1.5em;
        font-weight: bold;
        color: #667eea;
      }

      .warning {
        background: #fff3cd;
        color: #856404;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
        margin: 15px 0;
      }

      .success {
        background: #d4edda;
        color: #155724;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #28a745;
        margin: 15px 0;
      }

      .error {
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #dc3545;
        margin: 15px 0;
      }

      .radio-group {
        display: flex;
        gap: 20px;
        margin-top: 10px;
      }

      .radio-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .radio-item input[type="radio"] {
        width: auto;
      }

      .key-length-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .key-length-table th,
      .key-length-table td {
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid #e9ecef;
      }

      .key-length-table th {
        background: #667eea;
        color: white;
        font-weight: 600;
      }

      .key-length-table tr:nth-child(even) {
        background: #f8f9fa;
      }

      .best-key-length {
        background: #d4edda !important;
        font-weight: bold;
      }

      @media (max-width: 768px) {
        .container {
          margin: 10px;
          border-radius: 15px;
        }

        .header {
          padding: 20px;
        }

        .header h1 {
          font-size: 2em;
        }

        .tab-content {
          padding: 20px;
        }

        .tabs {
          flex-direction: column;
        }

        .analysis-results {
          grid-template-columns: 1fr;
        }
      }

      .hidden {
        display: none;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üîê Cifra de Vigen√®re</h1>
        <p>
          Implementa√ß√£o completa com an√°lise criptogr√°fica e ataque por
          frequ√™ncia
        </p>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="switchTab(event, 'encrypt')">
          Cifrar
        </button>
        <button class="tab" onclick="switchTab(event, 'decrypt')">
          Decifrar
        </button>
        <button class="tab" onclick="switchTab(event, 'attack')">
          Ataque Criptanal√≠tico
        </button>
      </div>

      <!-- TAB CIFRAR -->
      <div id="encrypt" class="tab-content active">
        <h2>üîí Cifrar Mensagem</h2>

        <div class="form-group">
          <label for="encrypt-text">Texto a ser cifrado:</label>
          <textarea
            id="encrypt-text"
            placeholder="Digite seu texto aqui..."
            rows="6"
          ></textarea>
        </div>

        <div class="form-group">
          <label>Ou carregue um arquivo:</label>
          <div class="file-input-wrapper">
            <div class="file-input">
              <input
                type="file"
                id="encrypt-file"
                accept=".txt"
                onchange="loadFile(this, 'encrypt-text')"
              />
              üìÅ Clique para selecionar um arquivo de texto
            </div>
          </div>
        </div>

        <div class="form-group">
          <label for="encrypt-key">Chave (apenas letras, sem espa√ßos):</label>
          <input
            type="text"
            id="encrypt-key"
            placeholder="Ex: CHAVE"
            pattern="[A-Za-z]+"
            title="Apenas letras s√£o permitidas"
          />
        </div>

        <button class="btn btn-primary" onclick="encryptMessage()">
          üîí Cifrar Mensagem
        </button>
        <button class="btn btn-secondary" onclick="clearEncrypt()">
          Limpar
        </button>

        <div id="encrypt-result" class="result-area hidden">
          <h3>Resultado da Cifra√ß√£o:</h3>
          <div id="encrypt-output" class="result-text"></div>
          <button
            class="btn btn-success"
            onclick="downloadResult('encrypt-output', 'texto_cifrado.txt')"
          >
            üíæ Baixar Resultado
          </button>
        </div>
      </div>

      <!-- TAB DECIFRAR -->
      <div id="decrypt" class="tab-content">
        <h2>üîì Decifrar Mensagem</h2>

        <div class="form-group">
          <label for="decrypt-text">Texto cifrado:</label>
          <textarea
            id="decrypt-text"
            placeholder="Cole aqui o texto cifrado..."
            rows="6"
          ></textarea>
        </div>

        <div class="form-group">
          <label>Ou carregue um arquivo:</label>
          <div class="file-input-wrapper">
            <div class="file-input">
              <input
                type="file"
                id="decrypt-file"
                accept=".txt"
                onchange="loadFile(this, 'decrypt-text')"
              />
              üìÅ Clique para selecionar um arquivo de texto
            </div>
          </div>
        </div>

        <div class="form-group">
          <label for="decrypt-key">Chave:</label>
          <input
            type="text"
            id="decrypt-key"
            placeholder="Ex: CHAVE"
            pattern="[A-Za-z]+"
            title="Apenas letras s√£o permitidas"
          />
        </div>

        <button class="btn btn-primary" onclick="decryptMessage()">
          üîì Decifrar Mensagem
        </button>
        <button class="btn btn-secondary" onclick="clearDecrypt()">
          üóëÔ∏è Limpar
        </button>

        <div id="decrypt-result" class="result-area hidden">
          <h3>Resultado da Decifra√ß√£o:</h3>
          <div id="decrypt-output" class="result-text"></div>
          <button
            class="btn btn-success"
            onclick="downloadResult('decrypt-output', 'texto_decifrado.txt')"
          >
            üíæ Baixar Resultado
          </button>
        </div>
      </div>

      <!-- TAB ATAQUE -->
      <div id="attack" class="tab-content">
        <h2>Ataque Criptanal√≠tico</h2>
        <p>
          Este m√≥dulo utiliza an√°lise de frequ√™ncia e √çndice de Coincid√™ncia
          (IC) para tentar descobrir a chave usada na cifra de Vigen√®re.
        </p>

        <div class="form-group">
          <label for="attack-text">Texto cifrado para an√°lise:</label>
          <textarea
            id="attack-text"
            placeholder="Cole aqui o texto cifrado a ser analisado..."
            rows="6"
          ></textarea>
        </div>

        <div class="form-group">
          <label>Ou carregue um arquivo:</label>
          <div class="file-input-wrapper">
            <div class="file-input">
              <input
                type="file"
                id="attack-file"
                accept=".txt"
                onchange="loadFile(this, 'attack-text')"
              />
              üìÅ Clique para selecionar um arquivo de texto
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>Idioma prov√°vel do texto original:</label>
          <div class="radio-group">
            <div class="radio-item">
              <input
                type="radio"
                id="lang-pt"
                name="language"
                value="pt"
                checked
              />
              <label for="lang-pt">Portugu√™s</label>
            </div>
            <div class="radio-item">
              <input type="radio" id="lang-en" name="language" value="en" />
              <label for="lang-en">Ingl√™s</label>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>M√©todo de ataque:</label>
          <div class="radio-group">
            <div class="radio-item">
              <input
                type="radio"
                id="method-chi"
                name="method"
                value="chi"
                checked
              />
              <label for="method-chi">Qui-Quadrado (textos longos)</label>
            </div>
            <div class="radio-item">
              <input
                type="radio"
                id="method-simple"
                name="method"
                value="simple"
              />
              <label for="method-simple"
                >Correla√ß√£o Simples (textos curtos)</label
              >
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>Determina√ß√£o do tamanho da chave:</label>
          <div class="radio-group">
            <div class="radio-item">
              <input
                type="radio"
                id="key-auto"
                name="keymethod"
                value="auto"
                checked
              />
              <label for="key-auto">An√°lise autom√°tica</label>
            </div>
            <div class="radio-item">
              <input
                type="radio"
                id="key-manual"
                name="keymethod"
                value="manual"
              />
              <label for="key-manual">Especificar manualmente</label>
            </div>
          </div>
        </div>

        <div class="form-group hidden" id="manual-key-length-group">
          <label for="manual-key-length">Tamanho da chave (1-20):</label>
          <input
            type="number"
            id="manual-key-length"
            min="1"
            max="20"
            value="3"
          />
        </div>

        <button class="btn btn-primary" onclick="performAttack()">
          üéØ Iniciar Ataque
        </button>
        <button class="btn btn-secondary" onclick="clearAttack()">
          Limpar
        </button>

        <div id="attack-progress" class="hidden">
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          <p id="progress-text">Analisando texto...</p>
        </div>

        <div id="attack-result" class="result-area hidden">
          <h3>Resultado da An√°lise:</h3>

          <div class="analysis-results">
            <div class="analysis-card">
              <h4>Chave Recuperada</h4>
              <div class="value" id="recovered-key">-</div>
            </div>
            <div class="analysis-card">
              <h4>Tamanho da Chave</h4>
              <div class="value" id="key-length-result">-</div>
            </div>
            <div class="analysis-card">
              <h4>IC Global</h4>
              <div class="value" id="global-ic">-</div>
            </div>
            <div class="analysis-card">
              <h4>IC M√©dio (Tamanho Chave)</h4>
              <div class="value" id="avg-ic">-</div>
            </div>
          </div>

          <div id="key-length-analysis" class="hidden">
            <h4>An√°lise de Tamanhos de Chave:</h4>
            <table class="key-length-table" id="key-length-table">
              <thead>
                <tr>
                  <th>Tamanho</th>
                  <th>IC M√©dio</th>
                  <th>Avalia√ß√£o</th>
                </tr>
              </thead>
              <tbody id="key-length-tbody"></tbody>
            </table>
          </div>

          <h4>Texto Decifrado (Tentativa):</h4>
          <div id="attack-output" class="result-text"></div>

          <button class="btn btn-success" onclick="downloadAttackResults()">
            üíæ Baixar Relat√≥rio Completo
          </button>
        </div>
      </div>
    </div>

    <script>
      // Frequ√™ncias das letras em portugu√™s e ingl√™s
      const PT_FREQUENCIES = [
        0.1463, 0.0104, 0.0388, 0.0499, 0.1257, 0.0102, 0.013, 0.0128, 0.0618,
        0.004, 0.0002, 0.0278, 0.0474, 0.0505, 0.1073, 0.0252, 0.012, 0.0653,
        0.0781, 0.0434, 0.0463, 0.0167, 0.0001, 0.0021, 0.0001, 0.0047,
      ];

      const EN_FREQUENCIES = [
        0.0817, 0.0149, 0.0278, 0.0425, 0.127, 0.0223, 0.0202, 0.0609, 0.0697,
        0.0015, 0.0077, 0.0402, 0.0241, 0.0675, 0.0751, 0.0193, 0.0009, 0.0599,
        0.0633, 0.0906, 0.0276, 0.0098, 0.0236, 0.0015, 0.0197, 0.0007,
      ];

      const ALPHABET_SIZE = 26;
      const MAX_KEY_LENGTH_TO_TRY = 20;
      const TARGET_IC_PT = 0.0761384;
      const TARGET_IC_EN = 0.066699;

      // Vari√°veis globais para armazenar resultados do ataque
      let attackResults = {};

      // Fun√ß√£o para alternar entre abas
      function switchTab(event, tabName) {
        const tabs = document.querySelectorAll(".tab");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach((tab) => tab.classList.remove("active"));
        contents.forEach((content) => content.classList.remove("active"));

        event.target.classList.add("active");
        document.getElementById(tabName).classList.add("active");
      }

      // Fun√ß√£o para carregar arquivo
      function loadFile(input, targetId) {
        const file = input.files[0];
        if (file && file.type === "text/plain") {
          const reader = new FileReader();
          reader.onload = function (e) {
            document.getElementById(targetId).value = e.target.result;
          };
          reader.readAsText(file);
        } else if (file) {
          alert("Por favor, selecione apenas arquivos de texto (.txt)");
        }
      }

      // Fun√ß√£o para validar chave
      function validateKey(key) {
        return /^[A-Za-z]+$/.test(key) && key.length > 0;
      }

      // Fun√ß√£o de cifra√ß√£o Vigen√®re
      function vigenereEncrypt(plaintext, key) {
        key = key.toUpperCase();
        let result = "";
        let keyIndex = 0;

        for (let i = 0; i < plaintext.length; i++) {
          const char = plaintext[i];

          if (/[A-Za-z]/.test(char)) {
            const isUpper = char === char.toUpperCase();
            const charCode = char.toUpperCase().charCodeAt(0) - 65;
            const keyChar = key[keyIndex % key.length].charCodeAt(0) - 65;
            const encryptedChar = String.fromCharCode(
              ((charCode + keyChar) % 26) + 65
            );

            result += isUpper ? encryptedChar : encryptedChar.toLowerCase();
            keyIndex++;
          } else {
            result += char;
          }
        }

        return result;
      }

      // Fun√ß√£o de decifra√ß√£o Vigen√®re
      function vigenereDecrypt(ciphertext, key) {
        key = key.toUpperCase();
        let result = "";
        let keyIndex = 0;

        for (let i = 0; i < ciphertext.length; i++) {
          const char = ciphertext[i];

          if (/[A-Za-z]/.test(char)) {
            const isUpper = char === char.toUpperCase();
            const charCode = char.toUpperCase().charCodeAt(0) - 65;
            const keyChar = key[keyIndex % key.length].charCodeAt(0) - 65;
            const decryptedChar = String.fromCharCode(
              ((charCode - keyChar + 26) % 26) + 65
            );

            result += isUpper ? decryptedChar : decryptedChar.toLowerCase();
            keyIndex++;
          } else {
            result += char;
          }
        }

        return result;
      }

      // Fun√ß√£o para contar frequ√™ncias
      function countFrequencies(text) {
        const frequencies = new Array(26).fill(0);
        let total = 0;

        for (let char of text.toLowerCase()) {
          if (/[a-z]/.test(char)) {
            frequencies[char.charCodeAt(0) - 97]++;
            total++;
          }
        }

        return { frequencies, total };
      }

      // Fun√ß√£o para calcular √çndice de Coincid√™ncia
      function indexOfCoincidence(text) {
        const { frequencies, total } = countFrequencies(text);

        if (total <= 1) return 0;

        let sum = 0;
        for (let freq of frequencies) {
          sum += freq * (freq - 1);
        }

        return sum / (total * (total - 1));
      }

      // Fun√ß√£o para extrair sequ√™ncia
      function extractSequence(text, keyLength, offset) {
        let result = "";
        const cleanText = text.toLowerCase().replace(/[^a-z]/g, "");

        for (let i = offset; i < cleanText.length; i += keyLength) {
          result += cleanText[i];
        }

        return result;
      }

      // Fun√ß√£o para calcular IC m√©dio para um tamanho de chave
      function averageICForKeyLength(text, keyLength) {
        if (keyLength <= 0) return 0;

        let sumIC = 0;
        let validSequences = 0;

        for (let i = 0; i < keyLength; i++) {
          const sequence = extractSequence(text, keyLength, i);
          if (sequence.length > 1) {
            sumIC += indexOfCoincidence(sequence);
            validSequences++;
          }
        }

        return validSequences > 0 ? sumIC / validSequences : 0;
      }

      // Fun√ß√£o para encontrar o deslocamento mais prov√°vel (Qui-Quadrado)
      function findLikelyShiftChiSquared(sequence, expectedFreqs) {
        const { frequencies: observedCounts, total: totalChars } =
          countFrequencies(sequence);

        if (totalChars === 0) return 0;

        let minChiSquared = -1;
        let bestShift = 0;

        for (let g = 0; g < ALPHABET_SIZE; g++) {
          let currentChiSquared = 0;

          for (let i = 0; i < ALPHABET_SIZE; i++) {
            const observedCount = observedCounts[(i + g) % ALPHABET_SIZE];
            const expectedCount = expectedFreqs[i] * totalChars;

            if (expectedCount === 0) {
              if (observedCount > 0) {
                currentChiSquared += 1000;
              }
            } else {
              currentChiSquared +=
                Math.pow(observedCount - expectedCount, 2) / expectedCount;
            }
          }

          if (minChiSquared < 0 || currentChiSquared < minChiSquared) {
            minChiSquared = currentChiSquared;
            bestShift = g;
          }
        }

        return bestShift;
      }

      // Fun√ß√£o para encontrar o deslocamento mais prov√°vel (Correla√ß√£o Simples)
      function findLikelyShiftSimple(sequence, expectedFreqs) {
        const { frequencies: observedCounts, total: totalChars } =
          countFrequencies(sequence);

        if (totalChars === 0) return 0;

        let bestCorrelation = -1;
        let bestShift = 0;

        for (let g = 0; g < ALPHABET_SIZE; g++) {
          let correlation = 0;

          for (let i = 0; i < ALPHABET_SIZE; i++) {
            const observedFreq =
              observedCounts[(i + g) % ALPHABET_SIZE] / totalChars;
            correlation += observedFreq * expectedFreqs[i];
          }

          if (correlation > bestCorrelation) {
            bestCorrelation = correlation;
            bestShift = g;
          }
        }

        return bestShift;
      }

      // Fun√ß√£o para encontrar o tamanho da chave (continua√ß√£o)
      function findKeyLength(cleanedText, isPortuguese) {
        const targetIC = isPortuguese ? TARGET_IC_PT : TARGET_IC_EN;
        let bestAvgIC = 0;
        let bestLength = 1;
        const results = [];

        for (let i = 1; i <= MAX_KEY_LENGTH_TO_TRY; i++) {
          if (cleanedText.length < i * 2 && i > 1) {
            break;
          }

          const avgIC = averageICForKeyLength(cleanedText, i);
          results.push({
            length: i,
            avgIC: avgIC,
            score: Math.abs(avgIC - targetIC),
          });

          if (avgIC > bestAvgIC && avgIC > 0.03) {
            // Limiar m√≠nimo para considerar v√°lido
            bestAvgIC = avgIC;
            bestLength = i;
          }
        }

        // Ordenar por proximidade ao IC esperado
        results.sort((a, b) => a.score - b.score);

        return {
          bestLength: results.length > 0 ? results[0].length : bestLength,
          results: results,
        };
      }

      // Fun√ß√£o para recuperar a chave usando an√°lise de frequ√™ncia
      function recoverKey(cleanedText, keyLength, useChiSquared, isPortuguese) {
        const expectedFreqs = isPortuguese ? PT_FREQUENCIES : EN_FREQUENCIES;
        let key = "";

        for (let i = 0; i < keyLength; i++) {
          const sequence = extractSequence(cleanedText, keyLength, i);
          if (sequence.length === 0) {
            key += "A";
            continue;
          }

          const shift = useChiSquared
            ? findLikelyShiftChiSquared(sequence, expectedFreqs)
            : findLikelyShiftSimple(sequence, expectedFreqs);

          key += String.fromCharCode(65 + shift);
        }

        return key;
      }

      // Fun√ß√£o principal para cifrar mensagem
      function encryptMessage() {
        const text = document.getElementById("encrypt-text").value;
        const key = document.getElementById("encrypt-key").value;

        if (!text.trim()) {
          showMessage("Por favor, insira um texto para cifrar.", "error");
          return;
        }

        if (!validateKey(key)) {
          showMessage(
            "A chave deve conter apenas letras e n√£o pode estar vazia.",
            "error"
          );
          return;
        }

        try {
          const encrypted = vigenereEncrypt(text, key);
          document.getElementById("encrypt-output").textContent = encrypted;
          document.getElementById("encrypt-result").classList.remove("hidden");
          showMessage("Texto cifrado com sucesso!", "success");
        } catch (error) {
          showMessage("Erro ao cifrar: " + error.message, "error");
        }
      }

      // Fun√ß√£o principal para decifrar mensagem
      function decryptMessage() {
        const text = document.getElementById("decrypt-text").value;
        const key = document.getElementById("decrypt-key").value;

        if (!text.trim()) {
          showMessage("Por favor, insira um texto para decifrar.", "error");
          return;
        }

        if (!validateKey(key)) {
          showMessage(
            "A chave deve conter apenas letras e n√£o pode estar vazia.",
            "error"
          );
          return;
        }

        try {
          const decrypted = vigenereDecrypt(text, key);
          document.getElementById("decrypt-output").textContent = decrypted;
          document.getElementById("decrypt-result").classList.remove("hidden");
          showMessage("Texto decifrado com sucesso!", "success");
        } catch (error) {
          showMessage("Erro ao decifrar: " + error.message, "error");
        }
      }

      // Fun√ß√£o principal para realizar ataque
      async function performAttack() {
        const text = document.getElementById("attack-text").value;

        if (!text.trim()) {
          showMessage(
            "Por favor, insira um texto cifrado para an√°lise.",
            "error"
          );
          return;
        }

        const isPortuguese =
          document.querySelector('input[name="language"]:checked').value ===
          "pt";
        const useChiSquared =
          document.querySelector('input[name="method"]:checked').value ===
          "chi";
        const isAutoKeyLength =
          document.querySelector('input[name="keymethod"]:checked').value ===
          "auto";

        // Limpar texto (apenas letras)
        const cleanedText = text.toLowerCase().replace(/[^a-z]/g, "");

        if (cleanedText.length < 50) {
          showMessage(
            "Texto muito curto para an√°lise criptogr√°fica. √â recomendado pelo menos 50 caracteres alfab√©ticos.",
            "warning"
          );
        }

        // Mostrar progresso
        document.getElementById("attack-progress").classList.remove("hidden");
        updateProgress(0, "Preparando an√°lise...");

        try {
          await new Promise((resolve) => setTimeout(resolve, 500)); // Simular processamento

          // Calcular IC global
          const globalIC = indexOfCoincidence(cleanedText);
          updateProgress(20, "Calculando √çndice de Coincid√™ncia...");

          let keyLength;
          let keyLengthResults = [];

          if (isAutoKeyLength) {
            updateProgress(40, "Determinando tamanho da chave...");
            const keyLengthAnalysis = findKeyLength(cleanedText, isPortuguese);
            keyLength = keyLengthAnalysis.bestLength;
            keyLengthResults = keyLengthAnalysis.results;
          } else {
            keyLength =
              parseInt(document.getElementById("manual-key-length").value) || 3;
          }

          updateProgress(60, "Recuperando chave...");

          // Recuperar chave
          const recoveredKey = recoverKey(
            cleanedText,
            keyLength,
            useChiSquared,
            isPortuguese
          );

          updateProgress(80, "Decifrando texto...");

          // Decifrar com a chave recuperada
          const decryptedText = vigenereDecrypt(text, recoveredKey);

          // Calcular IC m√©dio para o tamanho da chave encontrado
          const avgIC = averageICForKeyLength(cleanedText, keyLength);

          updateProgress(100, "An√°lise conclu√≠da!");

          // Armazenar resultados para download
          attackResults = {
            originalText: text,
            cleanedText: cleanedText,
            recoveredKey: recoveredKey,
            keyLength: keyLength,
            globalIC: globalIC,
            avgIC: avgIC,
            decryptedText: decryptedText,
            keyLengthResults: keyLengthResults,
            method: useChiSquared ? "Qui-Quadrado" : "Correla√ß√£o Simples",
            language: isPortuguese ? "Portugu√™s" : "Ingl√™s",
          };

          // Mostrar resultados
          displayAttackResults(attackResults);

          setTimeout(() => {
            document.getElementById("attack-progress").classList.add("hidden");
          }, 1000);
        } catch (error) {
          document.getElementById("attack-progress").classList.add("hidden");
          showMessage("Erro durante a an√°lise: " + error.message, "error");
        }
      }

      // Fun√ß√£o para exibir resultados do ataque
      function displayAttackResults(results) {
        document.getElementById("recovered-key").textContent =
          results.recoveredKey;
        document.getElementById("key-length-result").textContent =
          results.keyLength;
        document.getElementById("global-ic").textContent =
          results.globalIC.toFixed(6);
        document.getElementById("avg-ic").textContent =
          results.avgIC.toFixed(6);
        document.getElementById("attack-output").textContent =
          results.decryptedText;

        // Mostrar tabela de an√°lise de tamanhos de chave se dispon√≠vel
        if (results.keyLengthResults && results.keyLengthResults.length > 0) {
          displayKeyLengthTable(results.keyLengthResults, results.keyLength);
          document
            .getElementById("key-length-analysis")
            .classList.remove("hidden");
        } else {
          document
            .getElementById("key-length-analysis")
            .classList.add("hidden");
        }

        document.getElementById("attack-result").classList.remove("hidden");
        showMessage(
          "An√°lise criptogr√°fica conclu√≠da! Verifique se o texto decifrado faz sentido.",
          "success"
        );
      }

      // Fun√ß√£o para exibir tabela de an√°lise de tamanhos de chave
      function displayKeyLengthTable(results, bestLength) {
        const tbody = document.getElementById("key-length-tbody");
        tbody.innerHTML = "";

        results.slice(0, 10).forEach((result) => {
          const row = document.createElement("tr");
          if (result.length === bestLength) {
            row.classList.add("best-key-length");
          }

          const evaluation =
            result.avgIC > 0.06
              ? "Muito Prov√°vel"
              : result.avgIC > 0.04
              ? "Prov√°vel"
              : result.avgIC > 0.02
              ? "Poss√≠vel"
              : "Improv√°vel";

          row.innerHTML = `
                    <td>${result.length}</td>
                    <td>${result.avgIC.toFixed(6)}</td>
                    <td>${evaluation}</td>
                `;
          tbody.appendChild(row);
        });
      }

      // Fun√ß√£o para atualizar barra de progresso
      function updateProgress(percent, text) {
        document.getElementById("progress-fill").style.width = percent + "%";
        document.getElementById("progress-text").textContent = text;
      }

      // Fun√ß√£o para mostrar mensagens
      function showMessage(message, type = "info") {
        // Remove mensagens existentes
        const existingMessages = document.querySelectorAll(".message-alert");
        existingMessages.forEach((msg) => msg.remove());

        const messageDiv = document.createElement("div");
        messageDiv.className = `message-alert ${type}`;
        messageDiv.textContent = message;

        // Adiciona estilos baseados no tipo
        if (type === "success") {
          messageDiv.classList.add("success");
        } else if (type === "error") {
          messageDiv.classList.add("error");
        } else if (type === "warning") {
          messageDiv.classList.add("warning");
        }

        // Insere no topo do container ativo
        const activeTab = document.querySelector(".tab-content.active");
        if (activeTab) {
          activeTab.insertBefore(messageDiv, activeTab.firstChild);

          // Remove automaticamente ap√≥s 5 segundos
          setTimeout(() => {
            if (messageDiv.parentNode) {
              messageDiv.remove();
            }
          }, 5000);
        }
      }

      // Fun√ß√£o para baixar resultado
      function downloadResult(elementId, filename) {
        const content = document.getElementById(elementId).textContent;
        downloadText(content, filename);
      }

      // Fun√ß√£o para baixar relat√≥rio completo do ataque
      function downloadAttackResults() {
        if (!attackResults || Object.keys(attackResults).length === 0) {
          showMessage(
            "Nenhum resultado de ataque dispon√≠vel para download.",
            "error"
          );
          return;
        }

        let report = `RELAT√ìRIO DE AN√ÅLISE CRIPTOGR√ÅFICA - CIFRA DE VIGEN√àRE
============================================================

Data: ${new Date().toLocaleString()}
M√©todo: ${attackResults.method}
Idioma: ${attackResults.language}

RESULTADOS:
-----------
Chave Recuperada: ${attackResults.recoveredKey}
Tamanho da Chave: ${attackResults.keyLength}
√çndice de Coincid√™ncia Global: ${attackResults.globalIC.toFixed(6)}
IC M√©dio (Tamanho da Chave): ${attackResults.avgIC.toFixed(6)}

TEXTO ORIGINAL (CIFRADO):
------------------------
${attackResults.originalText}

TEXTO DECIFRADO:
---------------
${attackResults.decryptedText}

`;

        if (
          attackResults.keyLengthResults &&
          attackResults.keyLengthResults.length > 0
        ) {
          report += `AN√ÅLISE DE TAMANHOS DE CHAVE:
----------------------------
`;
          attackResults.keyLengthResults.slice(0, 10).forEach((result) => {
            const evaluation =
              result.avgIC > 0.06
                ? "Muito Prov√°vel"
                : result.avgIC > 0.04
                ? "Prov√°vel"
                : result.avgIC > 0.02
                ? "Poss√≠vel"
                : "Improv√°vel";
            report += `Tamanho ${result.length}: IC = ${result.avgIC.toFixed(
              6
            )} (${evaluation})\n`;
          });
        }

        report += `
OBSERVA√á√ïES:
-----------
- Esta an√°lise √© baseada em m√©todos estat√≠sticos e pode n√£o ser 100% precisa
- Para textos curtos, a precis√£o pode ser reduzida
- Verifique se o texto decifrado faz sentido no contexto esperado
- IC pr√≥ximo a 0.074 (portugu√™s) ou 0.067 (ingl√™s) indica texto em linguagem natural

Gerado por: Analisador de Cifra de Vigen√®re
`;

        downloadText(report, "relatorio_analise_vigenere.txt");
      }

      // Fun√ß√£o auxiliar para download de texto
      function downloadText(content, filename) {
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }

      // Fun√ß√µes para limpar campos
      function clearEncrypt() {
        document.getElementById("encrypt-text").value = "";
        document.getElementById("encrypt-key").value = "";
        document.getElementById("encrypt-file").value = "";
        document.getElementById("encrypt-result").classList.add("hidden");
      }

      function clearDecrypt() {
        document.getElementById("decrypt-text").value = "";
        document.getElementById("decrypt-key").value = "";
        document.getElementById("decrypt-file").value = "";
        document.getElementById("decrypt-result").classList.add("hidden");
      }

      function clearAttack() {
        document.getElementById("attack-text").value = "";
        document.getElementById("attack-file").value = "";
        document.getElementById("attack-result").classList.add("hidden");
        document.getElementById("attack-progress").classList.add("hidden");
        document.getElementById("key-length-analysis").classList.add("hidden");
        attackResults = {};
      }

      // Event listeners para controles din√¢micos
      document.addEventListener("DOMContentLoaded", function () {
        // Listener para mudan√ßa no m√©todo de determina√ß√£o do tamanho da chave
        const keyMethodRadios = document.querySelectorAll(
          'input[name="keymethod"]'
        );
        keyMethodRadios.forEach((radio) => {
          radio.addEventListener("change", function () {
            const manualGroup = document.getElementById(
              "manual-key-length-group"
            );
            if (this.value === "manual") {
              manualGroup.classList.remove("hidden");
            } else {
              manualGroup.classList.add("hidden");
            }
          });
        });

        // Valida√ß√£o em tempo real das chaves
        const keyInputs = ["encrypt-key", "decrypt-key"];
        keyInputs.forEach((inputId) => {
          const input = document.getElementById(inputId);
          input.addEventListener("input", function () {
            this.value = this.value.replace(/[^A-Za-z]/g, "");
          });
        });

        // Listener para arquivos
        const fileInputs = document.querySelectorAll('input[type="file"]');
        fileInputs.forEach((input) => {
          input.addEventListener("change", function () {
            const fileName = this.files[0]?.name || "";
            const wrapper = this.closest(".file-input");
            if (fileName) {
              wrapper.style.background = "#e8f5e8";
              wrapper.innerHTML = `üìÅ Arquivo selecionado: ${fileName}<input type="file" accept=".txt" style="position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer;">`;
              // Re-adicionar o event listener
              wrapper
                .querySelector("input")
                .addEventListener("change", arguments.callee);
            }
          });
        });
      });

      // Fun√ß√£o para formatar texto para exibi√ß√£o
      function formatTextDisplay(text) {
        if (text.length > 5000) {
          return (
            text.substring(0, 5000) +
            "\n\n[... texto truncado para exibi√ß√£o ...]"
          );
        }
        return text;
      }

      // Valida√ß√µes adicionais
      function validateTextLength(text, minLength = 10) {
        const cleanText = text.replace(/[^a-zA-Z]/g, "");
        return cleanText.length >= minLength;
      }

      function estimateAttackSuccess(ic, textLength) {
        let confidence = "Baixa";

        if (textLength > 500 && ic > 0.05) {
          confidence = "Alta";
        } else if (textLength > 200 && ic > 0.04) {
          confidence = "M√©dia";
        } else if (textLength > 100 && ic > 0.03) {
          confidence = "Baixa-M√©dia";
        }

        return confidence;
      }

      // Fun√ß√£o para exportar chave recuperada
      function exportRecoveredKey() {
        if (!attackResults.recoveredKey) {
          showMessage("Nenhuma chave recuperada dispon√≠vel.", "error");
          return;
        }

        const keyInfo = `Chave Recuperada: ${
          attackResults.recoveredKey
        }\nTamanho: ${attackResults.keyLength}\nM√©todo: ${
          attackResults.method
        }\nData: ${new Date().toLocaleString()}`;
        downloadText(keyInfo, "chave_recuperada.txt");
      }

      // Adicionar bot√£o para exportar chave (pode ser usado no HTML se necess√°rio)
      function addExportKeyButton() {
        const resultArea = document.getElementById("attack-result");
        if (resultArea && !document.getElementById("export-key-btn")) {
          const exportBtn = document.createElement("button");
          exportBtn.id = "export-key-btn";
          exportBtn.className = "btn btn-secondary";
          exportBtn.innerHTML = "üîë Exportar Chave";
          exportBtn.onclick = exportRecoveredKey;

          const downloadBtn = resultArea.querySelector(".btn-success");
          if (downloadBtn) {
            downloadBtn.parentNode.insertBefore(exportBtn, downloadBtn);
          }
        }
      }

      // Melhorar feedback visual durante opera√ß√µes
      function showLoading(elementId, show = true) {
        const element = document.getElementById(elementId);
        if (!element) return;

        if (show) {
          element.disabled = true;
          const originalText = element.textContent;
          element.innerHTML = '<span class="loading"></span>' + originalText;
          element.dataset.originalText = originalText;
        } else {
          element.disabled = false;
          element.textContent =
            element.dataset.originalText ||
            element.textContent.replace(/^.*?\s/, "");
        }
      }
    </script>
  </body>
</html>
